---
title: Migrating
description: Guides on how to move your user data from another authentication
  platform to Clerk.
lastUpdated: 2025-11-12T18:53:03.000Z
sdkScoped: "false"
canonical: /docs/guides/development/migrating/overview
sourceFile: /docs/guides/development/migrating/overview.mdx
---

## Migration tooling

To aid in basic migrations, Clerk provides an open-source script that takes a JSON file as input, containing a list of users, and creates a user in Clerk using the Backend API. The script respects the [backend rate limits](/docs/guides/how-clerk-works/system-limits#backend-api-requests) and gracefully handles errors. We suggest you customize the [Zod schema](https://github.com/clerk/migration-script/blob/main/index.ts#L25-L43){{ target: '_blank' }} to your application's needs.

To use Clerk's migration script, clone the [repository](https://github.com/clerk/migration-script) and follow the instructions in the `README`.

## Migration strategies

There are typically two main strategies for migrating your existing user management from a different platform into Clerk:

* [Basic Export / Import](#basic-export-import)
* [Trickle migration](#trickle-migration)

Each of these have trade-offs you'll need to consider for your application and its users.

## Basic export/import

With basic export/import, you're taking an export from your previous tool and importing data into Clerk. The most common way to handle this is by making use of the [`CreateUser`](/docs/reference/backend-api/tag/Users#operation/CreateUser){{ target: '_blank' }} Backend API endpoint. It's important to note that the `CreateUser` endpoint is rate limited. For more information, see the [guide on rate limits](/docs/guides/how-clerk-works/system-limits#backend-api-requests).

You'll also need to provide your `password_hasher` value (the hashing algorithm used to generate the password digest) and in some instances Clerk will transparently upgrade your users' password hashes to the more secure Bcrypt hashing algorithm. More details on this topic are available in the [Backend API reference docs](/docs/reference/backend-api/tag/Users#operation/CreateUser!path=password_hasher\&t=request){{ target: '_blank' }}.

### Considerations

#### Data consistency

Consider that any export of your data will be a snapshot in time. This means that there is a potential of your data being out of sync at the time of import. To work around this you might script and coordinate the export and import actions to be as close in time as possible, or you might schedule some kind of downtime or maintenance window to complete this action. Be sure to consider Clerk API rate limits when evaluating a potentially time-sensitive migration approach.

#### Active sessions/session management

Another consideration is centered around how you handle session management. While most authentication providers don't provide session management out-of-the-box, Clerk does. This means that when you switch over to using Clerk, you'll be changing the system that handles your users' active sessions. This will likely end any currently active sessions initiated by your previous session management service (unless you are able to gracefully handle this somehow within your architecture).

#### Foreign keys

In your previous system, you likely had some kind of ID/foreign key that you were using. As you migrate data into Clerk, you might want to continue referencing that previous ID alongside Clerk's provided user IDs. While each use case might have some variation, a common strategy is to store previous IDs as an `external_id`. You can then use Clerk's JWT customization to enrich a `userId` value with the `external_id` when present, or fallback to using Clerk's native ID when dealing with new users who don't have an `external_id` from your legacy system. You can configure this in the [**Sessions**](https://dashboard.clerk.com/~/sessions) page in the Clerk Dashboard. Under **Customize session token**, in the **Claims** editor, enter the following JSON and select **Save**. If you have already customized your session token, you may need to merge this with what you currently have.

```json
{
  "userId": "{{user.external_id || user.id}}"
}
```

## Trickle migration

With a trickle migration, you are slowly migrating your users from your previous system into Clerk. Depending on your application's needs, this can be a great way to accomplish migration in a gradual and more controlled way. With a trickle migration, you are keeping both systems running for some period of time, handling the transition between systems behind the scenes, and then eventually cutting over fully to Clerk as your user and session management system of record. By handling this transition gradually, you'll maintain more control and put less pressure on a single coordinated event.

### Considerations

#### The cost and overhead of running two systems in parallel

Because you'll need both systems available when doing a gradual migration, there is naturally additional short-term costs related to having both running systems at the same time.

> \[!NOTE]
> It's important to note that Clerk only charges by *Monthly Active Users* and never based on your total number of Users in the user table â€“ so during this period you'll only be charged for users who create an active session within Clerk. Head to our [pricing page](/pricing) to get the full details on how Clerk charges.

#### Determining the appropriate length of time

As part of the trickle migration, you'll need to determine an appropriate length of time for the migration to take place. For some applications this might be a few weeks, but for others it might be more appropriate to run this for months. Your hard-costs, coordination costs, underlying complexity, and the amount of active users you expect in your migration time-window should guide your decision here.

#### Dealing with inactive users

A trickle migration is great for upgrading active users and sessions to take advantage of Clerk, but there will always be some users who won't create an active session within the migration window and will need to be migrated by other means, typically via [basic export/import](#basic-export-import). A trickle migration lowers coordination risk because the remaining inactive users are fewer, so data de-synchronization risk drops, too.

## Migrating from Clerk

There are two main ways to migrate away from Clerk:

* [Export your user data from the Clerk Dashboard](#export-your-users-data-from-the-clerk-dashboard)
* [Programmatically get your user data](#access-user-data-in-the-backend)

### Export your users' data from the Clerk Dashboard

Users who are either admins or are in their personal workspace can export and download a CSV file containing a list of their application's users that *includes their hashed passwords*. Users can also view detailed export and download history logs. These logs offer a record of previous export actions, ensuring visibility and traceability of data exports.

To export your users' data:

1. In the Clerk Dashboard, navigate to the application's [**Settings**](https://dashboard.clerk.com/~/settings).
2. In the **User Exports** section, select **Export all users**.
3. A new entry in the export history will appear. Select the **Download** button to download the CSV file.

### Access user data in the backend

You can programmatically retrieve a list of your user's and their information by using the [`GetUserList`](/docs/reference/backend-api/tag/Users#operation/GetUserList){{ target: '_blank' }} Backend API endpoint, or the JS Backend SDK's <SDKLink href="/docs/reference/backend/user/get-user-list" sdks={["js-backend"]} code={true}>getUserList()</SDKLink> method which is a wrapper around the Backend API endpoint.


# Example script

```typescript
import { config } from "dotenv";
config();

import * as fs from "fs";
import * as z from "zod";
import clerkClient from "@clerk/clerk-sdk-node";
import ora, { Ora } from "ora";

const SECRET_KEY = process.env.CLERK_SECRET_KEY;
const DELAY = parseInt(process.env.DELAY_MS ?? `1_000`);
const RETRY_DELAY = parseInt(process.env.RETRY_DELAY_MS ?? `10_000`);
const IMPORT_TO_DEV = process.env.IMPORT_TO_DEV_INSTANCE ?? "false";
const OFFSET = parseInt(process.env.OFFSET ?? `0`);

if (!SECRET_KEY) {
	throw new Error(
		"CLERK_SECRET_KEY is required. Please copy .env.example to .env and add your key."
	);
}

if (SECRET_KEY.split("_")[1] !== "live" && IMPORT_TO_DEV === "false") {
	throw new Error(
		"The Clerk Secret Key provided is for a development instance. Development instances are limited to 500 users and do not share their userbase with production instances. If you want to import users to your development instance, please set 'IMPORT_TO_DEV_INSTANCE' in your .env to 'true'."
	);
}

const userSchema = z.object({
	/** The ID of the user as used in your external systems or your previous authentication solution. Must be unique across your instance. */
	userId: z.string(),
	/** Email address to set as User's primary email address. */
	email: z.string().email(),
	/** The first name to assign to the user */
	firstName: z.string().optional(),
	/** The last name to assign to the user */
	lastName: z.string().optional(),
	/** The plaintext password to give the user. Must be at least 8 characters long, and can not be in any list of hacked passwords. */
	password: z.string().optional(),
	/** The hashing algorithm that was used to generate the password digest.
	 * @see https://clerk.com/docs/reference/backend-api/tag/Users#operation/CreateUser!path=password_hasher&t=request
	 */
	passwordHasher: z
		.enum([
			"argon2i",
			"argon2id",
			"bcrypt",
			"bcrypt_sha256_django",
			"ldap_ssha",
			"md5",
			"md5_phpass",
			"pbkdf2_sha256",
			"pbkdf2_sha256_django",
			"pbkdf2_sha1",
			"phpass",
			"scrypt_firebase",
			"scrypt_werkzeug",
			"sha256",
		])
		.optional(),
	/** Metadata saved on the user, that is visible to both your Frontend and Backend APIs */
	public_metadata: z.record(z.string(), z.unknown()).optional(),
	/** Metadata saved on the user, that is only visible to your Backend APIs */
	private_metadata: z.record(z.string(), z.unknown()).optional(),
	/** Metadata saved on the user, that can be updated from both the Frontend and Backend APIs. Note: Since this data can be modified from the frontend, it is not guaranteed to be safe. */
	unsafe_metadata: z.record(z.string(), z.unknown()).optional(),
});

type User = z.infer<typeof userSchema>;

const createUser = (userData: User) =>
	userData.password
		? clerkClient.users.createUser({
				externalId: userData.userId,
				emailAddress: [userData.email],
				firstName: userData.firstName,
				lastName: userData.lastName,
				passwordDigest: userData.password,
				passwordHasher: userData.passwordHasher,
				privateMetadata: userData.private_metadata,
				publicMetadata: userData.public_metadata,
				unsafeMetadata: userData.unsafe_metadata,
		  })
		: clerkClient.users.createUser({
				externalId: userData.userId,
				emailAddress: [userData.email],
				firstName: userData.firstName,
				lastName: userData.lastName,
				skipPasswordRequirement: true,
				privateMetadata: userData.private_metadata,
				publicMetadata: userData.public_metadata,
				unsafeMetadata: userData.unsafe_metadata,
		  });

const now = new Date().toISOString().split(".")[0]; // YYYY-MM-DDTHH:mm:ss
function appendLog(payload: any) {
	fs.appendFileSync(
		`./migration-log-${now}.json`,
		`\n${JSON.stringify(payload, null, 2)}`
	);
}

let migrated = 0;
let alreadyExists = 0;

async function processUserToClerk(userData: User, spinner: Ora) {
	const txt = spinner.text;
	try {
		const parsedUserData = userSchema.safeParse(userData);
		if (!parsedUserData.success) {
			throw parsedUserData.error;
		}
		await createUser(parsedUserData.data);

		migrated++;
	} catch (error) {
		if (error.status === 422) {
			appendLog({ userId: userData.userId, ...error });
			alreadyExists++;
			return;
		}

		// Keep cooldown in case rate limit is reached as a fallback if the thread blocking fails
		if (error.status === 429) {
			spinner.text = `${txt} - rate limit reached, waiting for ${RETRY_DELAY} ms`;
			await rateLimitCooldown();
			spinner.text = txt;
			return processUserToClerk(userData, spinner);
		}

		appendLog({ userId: userData.userId, ...error });
	}
}

async function cooldown() {
	await new Promise((r) => setTimeout(r, DELAY));
}

async function rateLimitCooldown() {
	await new Promise((r) => setTimeout(r, RETRY_DELAY));
}

async function main() {
	console.log(`Clerk User Migration Utility`);

	const inputFileName = process.argv[2] ?? "users.json";

	console.log(`Fetching users from ${inputFileName}`);

	const parsedUserData: any[] = JSON.parse(
		fs.readFileSync(inputFileName, "utf-8")
	);
	const offsetUsers = parsedUserData.slice(OFFSET);
	console.log(
		`users.json found and parsed, attempting migration with an offset of ${OFFSET}`
	);

	let i = 0;
	const spinner = ora(`Migrating users`).start();

	for (const userData of offsetUsers) {
		spinner.text = `Migrating user ${i}/${offsetUsers.length}, cooldown`;
		await cooldown();
		i++;
		spinner.text = `Migrating user ${i}/${offsetUsers.length}`;
		await processUserToClerk(userData, spinner);
	}

	spinner.succeed(`Migration complete`);
	return;
}

main().then(() => {
	console.log(`${migrated} users migrated`);
	console.log(`${alreadyExists} users failed to upload`);
});
```
